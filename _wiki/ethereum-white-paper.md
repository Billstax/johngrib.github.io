---
layout  : wiki
title   : (요약) 이더리움 백서
summary : Ethereum White Paper
date    : 2019-01-22 22:56:21 +0900
updated : 2019-01-25 10:17:58 +0900
tags    : blockchain
toc     : true
public  : true
parent  : what
latex   : false
---
* TOC
{:toc}

>
* 면책조항
    * 이 문서는 개인의 학습을 위해 [이더리움 백서](https://github.com/ethereum/wiki/wiki/%5BKorean%5D-White-Paper )를 읽으면서 요약 정리한 노트입니다.
    * 제가 잘못 이해했거나 착각하여, 적절하지 않은 단어나 잘못된 내용을 적은 문장이 있을 수 있습니다.
    * 블록체인, 비트코인, 이더리움에 대해 자세히 알고 싶다면 이 노트가 아니라 해당 기술의 백서 또는 전문서를 조회하세요.


# 차세대 스마트 컨트랙트와 탈중앙화된 어플리케이션 플랫폼

* 비트코인의 중요한 측면: 분산합의 수단으로서의 블록체인 기술.
* 블록체인의 활용
    * 컬러드 코인(colored coins): 사용자 정의 화폐와 금융상품
    * 스마트 자산(smart property): 물리적 대상의 소유권을 표현
    * 네임코인(Name coin): 도메인 이름과 같은 비동질적 자산을 기록
    * 스마트 컨트랙트(smart contracts): 계약규칙을 구현한 코드로 디지털 자산을 관리
    * 탈중앙화된 자율 조직(decentralized autonomous organizations, DAOs)
* 이더리움은 튜링 완전한 프로그래밍 언어가 심어진 블록체인이다.
    * 상태 변환 기능이 포함된 계약을 작성할 수 있음.

# 비트코인과 기존 개념들 소개

## 역사

* 1980~90년대: 익명 e-cash 프로토콜.
    * 중앙집권 중개인에 의존하여 별로 주목받지 못함.
* 1998: b-money
    * 분산 합의, 계산 퍼즐을 푸는 방식으로 화폐를 발행하는 아이디어.
    * 분산 합의는 구현하지 못함.
* 2005: Hall Finney
    * 작업증명(proof of work) 개념 소개
* 2009: 사토시 나카모토의 탈중앙화된 화폐
    * 공개키 암호화 방식의 소유권 관리 + **작업 증명** 합의 알고리즘

### 작업 증명(proof of work)

작업 증명은 두 가지 문제를 동시에 해결하기 때문에 혁신적이다.

1. 심플하고 효과적인 합의 알고리즘.
    * 네트워크의 모든 노드가 표준 업데이트 집합에 공동으로 동의할 수 있게 됨.
2. 누구나 합의 프로세스에 참여할 수 있음.
    * 합의 결정권이 누구에게 있어야 하는가? → 해결
    * 각 노드의 결정권의 크기를 노드의 계산 능력에 직접 비례시키는 방식.
        * sybil attacks 방어 메커니즘 제공.

### 지분 증명(proof of stake)

* 작업 증명 이후 새로 등장한 합의 알고리즘.
* 각 노드의 계산능력이 아니라 화폐의 보유량에 따라 각 노드의 결정권을 계산한다.
* 작업 증명과 지분 증명 모두 암호화폐의 기반으로 사용할 수 있음.



## 상태변환 시스템으로서의 비트코인

* 암호화 화폐의 장부는 일종의 상태변환 시스템이다.
    * 상태변환 함수: `APPLY(S, TX) -> S' or ERROR`
        * S: 현재 상태
        * TX: 트랜잭션
        * S': 새로운 상태

```js
S = { Alice: 50, Bob: 50 }
TX = "Alice가 Bob에게 $20 송금"
_S = APPLY(S, TX)   // { Alice: 30, Bob: 70 }

S = { Alice: 50, Bob: 50 }
TX = "Alice가 Bob에게 $70 송금"
_S = APPLY(S, TX)   // ERROR
```

### 비트코인 상태와 트랜잭션

* 상태 S
    * 생성됐지만 아직 사용하지 않은 모든 코인의 집합.
    * 소비되지 않은 트랜잭션 출력(UTXO: Unspent Transaction Outputs)
    * 각 UTXO 에는 다음 정보가 들어 있다.
        * 코인의 금액
        * 소유자의 암호화된 공개키 정보(소유자의 주소)
* 트랜잭션 TX
    * 입력(들)
        * 보내는 쪽 지갑 주소에서 선택한 UTXO의 참조.
        * 보내는 쪽 지갑 주소에 대응되는 private key로 생성한 서명.
    * 출력
        * 상태에 추가될 새로운 UTXO 정보.

### 상태변환 함수

`APPLY(S,TX) -> S'`

1. TX의 각 입력에 대해:
    * `if` 참조된 UTXO가 S에 없다면, `return ERROR` (존재하지 않는 코인 사용 금지)
    * `if` 서명이 UTXO의 소유자와 매치되지 않으면, `return ERROR` (다른 사람의 코인 사용 금지)
1. 만약 입력의 UTXO들 금액의 총합이 출력 UTXO들 금액의 총합보다 작으면, `return ERROR` ()
2. 입력에 사용된 UTXO가 삭제되고 출력 UTXO가 추가된 S를 `return S`.

**상태변환 함수 사용 예**

* Alice가 Bob 에게 **11.7 BTC** 를 보내고자 한다.
    * 그런데 Alice가 갖고 있는 UTXO 는 **6 BTC, 4 BTC, 2 BTC** 뿐이라고 하자.
    * **6 + 4 + 2 = 12** 이므로 **12 BTC**를 보내고 **0.3 BTC**를 거스름돈으로 받으면 된다.
* 3 개의 UTXO 가 input 트랜잭션이 된다.
* 2 개의 output 이 나온다.
    1. Bob 소유의 **11.7 BTC**가 표시된 UTXO
    2. Alice 소유의 **0.3 BTC**가 표시된 UTXO

## 채굴

### 상태

* 최초의 상태(genesis state)부터 모든 트랜잭션을 순서대로 적용해서 얻어낼 수 있다.
    * 순서가 바뀌거나 중간에 다른 상태가 있으면 최종 상태는 완전히 다른 값이 되어버린다.

### 블록

* 노드는 트랜잭션을 모아 **Block**(트랜잭션 패키지)을 생성한다.
* 네트워크는 10분마다 하나의 블록을 생성하도록 계획되어 있다.
* 각 블록은 다음을 포함한다.
    * 블록 헤더
        * timestamp
        * nonce
        * 이전 블록의 hash (블록의 hash 란 블록 헤더의 hash 를 의미)
        * 모든 트랜잭션 정보로 생성한 Merkle tree 의 루트 hash.
    * 이전 블록 이후 발생한 모든 트랜잭션 목록

#### 블록 유효성을 확인하는 알고리즘

1. 블록이 참조하는 부모 블록이 유효한지 확인한다.
2. timestamp 값이 부모 블록의 timestamp 값보다 크고, 2시간 이내인지 확인한다.
3. **작업증명(proof of work)이 유효한지 확인한다.**
    * SHA-256 해시값이 목표값보다 작다면 OK.
4. `S[0]`를 이전 블록의 마지막 상태가 되도록 설정한다.
5. `TX`를 `n`개의 트랜잭션을 갖는 블록의 트랜잭션 목록으로 가정한다.
    * 트랜잭션을 순서대로 상태변환 함수에 넣어보면서 상태를 `S[1]`에서 `S[n]`까지 계속 업데이트해본다.
    * 그 과정에서 에러가 나면 false 를 리턴하며 종료한다.
6. `S[n]`을 이 블록의 마지막 상태로 등록하고 true 를 리턴한다.

### 작업증명

**작업증명의 조건**

* 블록의 SHA-256 해시값이 목표값보다 **작아야** 한다.
    * 해시값은 랜덤으로 생성된다.
* 목표값은 점점 작아진다.
    * 목표값은 2016개 블록마다 네트워크에 의해 감소하도록 조정된다.
    * 평균적으로 10분마다 새로운 블록이 생성되도록 조정된다.
* 블록 헤더의 nonce 값을 바꿔보면서 계속 해시값을 계산해보는 방법 밖에 없다.

**작업증명의 목적**

* 블록 생성을 어렵게 만들어서 조작을 방지한다.

**작업증명의 보상(채굴의 보상)**

1. 25 BTC
2. 출력금액보다 입력금액이 큰 트랜잭션이 있으면 차액 만큼의 BTC를 받는다(수수료).

* 위의 두 가지가 BTC가 새로 발행되는 **유일한 방법**이다.
* 즉, genesis state 에는 코인이 없었다.

#### 51% attack

* 공격자는 이중지불을 합리화하기 위해서 fork 를 시도할 수 있다.
    * 그러나 작업증명에 시간이 걸리기 때문에 공격자의 체인의 길이는 다른 체인에 비해 짧을 수 밖에 없다.

따라서 비트코인 네트워크는 가장 긴 블록체인을 TRUE로 인식하는 규칙을 갖는다.

* 그러므로 공격자가 자신의 체인을 가장 길게 만들기 위해서는
    * 네트워크의 다른 노드들의 계산능력 조합보다 더 큰 계산 능력을 가져야 한다.


## 머클트리

* 비트코인에서 블록이 저장되는 자료구조는 binary tree의 일종인 Merkle tree 이다.
* Merkle tree에서 노드의 hash 값은 두 자식 노드의 hash 값으로 만든다.
    * 그러므로, 누군가 특정 트랜잭션을 악의적으로 변경하면 모든 상위 노드의 hash 값이 바뀌게 된다.
    * 상위 노드의 hash 값이 바뀌면...
        * 해당 블록의 작업증명이 유효하지 않게 된다.
        * 완전히 다른 블록으로 인식되게 된다.

### full node, light node

* **완전 노드(full node)**: 각 블록의 모든 정보를 저장하고 처리하는 노드
    * 1달에 약 1GB씩 늘어나므로 용량이 엄청나다.
* **가벼운 노드(light node)**: 블록 헤더만 다운받아 갖고 있는 노드.
    * 블록헤더만으로 작업증명을 검증하므로 스마트폰처럼 용량이 작은 장비에서도 운용할 수 있다.

## 블록체인 기술을 이용한 다른 응용 사례

* 네임코인
    * 탈중앙화된 명칭 등록 데이터베이스
    * 아이디, 닉네임 등의 선점이 가능하고 다른 사람이 같은 이름을 쓸 수 없다.
* 컬러드 코인
    * 특정 비트코인 UTXO에 자신만의 "색깔"을 부여하여 새로운 화폐를 "발행"할 수 있다.
    * 사용자가 특정 색깔을 가진 UTXO만 지갑에 간직하고 그 코인을 보통 비트코인처럼 여기저기 보낼 수 있게 한다.
* 메타코인
    * 상태 이동 함수를 다르게 정의하여(APPLY'), 비트코인 시스템 위에서 운영되는 프로토콜을 갖는다.

**합의 프로토콜을 만드는 두 가지 접근방법**

1. 독립적인 네트워크를 세운다.
2. 비트코인 시스템과 연동되는 프로토콜을 세운다.

## 스크립팅

비트코인에 구현된 스크립트 언어에는 한계가 있다.

* 튜링 불완전성
    * 거래 증명시의 무한루프를 막기 위해 loop 명령을 의도적으로 누락시켰다.
    * loop가 없어도 if 문을 잔뜩 쓰면 가능하긴 한데 매우 비효율적이다.
* 가치무지하다
    * UTXO 스크립트만으로는 인출 액수를 세밀하게 통제하지 못한다.
    * 단순히 입력/출력이 있을 뿐이어서 다양한 종류의 계약 거래를 실행하지 못함.
* 다양한 상태를 표현할 수 없다
    * UTXO의 상태는 두 가지 뿐이다. 사용/사용안됨.
    * 다른 상태를 갖는 다중 단계 계약, 스크립트를 만들 수 없다.
        * 분산 환전 거래, 이중 암호 실행 프로토콜 등을 못 한다.
* 블록체인을 해독할 방법이 없다
    * UTXO는 nonce, timestamp, 이전 블록 hash 같은 블록체인 자료를 해독하지 못한다.
    * 그러므로 스크립트 언어는 무작위성을 다루지 못하게 된다.
    * 다양한 어플리케이션을 만들기 어렵게 된다.

발전된 어플리케이션을 만드는 3가지 접근법

1. 독립적인 블록체인을 만든다.
    * 만들기 어렵다는 문제가 있음.
2. 비트코인에 이미 내재된 스크립트를 이용한다.
    * 간단하지만 이용이 제한적이다.
3. 비트코인 상에서 작동하는 메타-규약을 만든다.
    * 간단하지만 확장이 곤란하다.

이런 문제들의 해결책으로 다음과 같은 특징들을 갖는, 이더리움을 만든다.

* 개발하기 쉽다.
* 더 강력한 라이트 클라이언트 기능을 갖는다.
* 경제적인 개발 환경
* 블록체인의 보안을 사용하는 어플리케이션을 만들 수 있는 프레임워크


# 이더리움


# Links

* [Ethereum White Paper 한국어](https://github.com/ethereum/wiki/wiki/%5BKorean%5D-White-Paper )
