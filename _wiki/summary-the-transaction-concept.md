---
layout  : wiki
title   : (요약) The Transaction Concept - Virtues and Limitations by Jim Gray, June 1981
summary : 짐 그레이의 트랜잭션 컨셉 요약
date    : 2021-04-25 14:44:36 +0900
updated : 2021-04-25 23:15:44 +0900
tag     : jim-gray transaction
toc     : true
public  : false
parent  : [[summary]]
latex   : false
---
* TOC
{:toc}

## 개요

이 개요는 내 편의대로 요약한 것이므로, 정확한 내용은 원문을 참고할 것.

...

## 요약

원문을 다음 링크에서 다운로드 받아 읽을 수 있다.

- The Transaction Concept: Virtues and Limitations by Jim Gray 1981
    - [PDF]( http://jimgray.azurewebsites.net/papers/thetransactionconcept.pdf )

### ABSTRACT

**개요**

트랜잭션은 세 가지 속성을 갖는 상태 변환을 의미한다.
- 원자성(all or nothing)
- 지속성(effects survive failures)
- 일관성(a correct transformation)

트랜잭션 개념은 데이터 관리 애플리케이션 구조화의 핵심이며, 이 개념은 일반적인 프로그래밍 체계에 적용할 수 있다.

- 이 논문은 트랜잭션 개념을 다시 설명하고 다양한 관점에서의 구현을 논의한다.
- 그러고 나서 추가적인 연구가 필요한 일부 영역을 설명할 것이다.
    1. 추상 데이터 유형 개념과 트랜잭션 개념의 통합.
    2. 트랜잭션이 하위 트랜잭션으로 구성되도록 허용하는 몇 가지 기술.
    3. 극단적으로 긴 시간(몇일, 몇 달 단위)동안 지속되는 트랜잭션의 처리.

### INTRODUCTION: What is a transaction?

**들어가며: 트랜잭션이란 무엇인가?**

트랜잭션 개념은 계약 규칙(contract law)에서 비롯된다.

- 계약을 맺을 때: 둘 이상의 당사자가 잠시 협상(negotiate)을 한 다음 거래(deal)를 한다.
- 거래: 문서의 공동 서명이나 다른 합의 행위(악수나 고개를 끄덕이는 등)에 의해 구속력이 있다.
- 만약 당사자들이 서로를 의심하거나, 안전한 거래를 원할 경우 중개자(intermediary)를 지정한다.
    - 이 중재자를 에스크로 담당자(escrow officer)라 부른다.

기독교식 결혼식은 그러한 계약의 좋은 예이다.

- 신부와 신랑은 몇일 ~ 몇년동안 협상을 한 다음, 결혼식을 진행할 목사를 임명한다.
- 목사는 가장 먼저 결혼식 하객들에게 결혼식에 반대하는 사람이 있는지를 묻는다.
- 목사는 그 다음으로 신부와 신랑에게 결혼에 동의하는지 물어본다.
- 신부와 신랑이 모두 동의하면, 목사는 두 사람이 부부가 되었음을 선언한다.

물론 계약은 단순한 약속의 일종이다. 따라서 개인이 마음먹고 규칙(법)을 위반하려 한다면 계약도 어길 수 있다.
- 그러나 법의 테두리 안에서 계약(transaction)은 처음부터 불법적으로 성사된 경우에만 해지될 수 있다.
- 잘못된 계약의 조정은 추가적인 보상 거래(법적 보상 포함)를 통해 이루어지게 된다.

트랜잭션 개념은 다음의 속성들로 나타낼 수 있다.

- 일관성(Consistency): 트랜잭션은 적법한 프로토콜을 따라야 한다.
- 원자성(Atomicity): 발생하거나 발생하지 않아야 한다. 계약에 모든 것이 구속되거나, 전혀 그렇지 않거나 해야 한다.
- 지속성(Durability): 일단 트랜잭션이 확정되면(committed), 취소할 수 없다.

### A GENERAL MODEL OF TRANSACTIONS

**일반적인 트랜잭션 모델**

트랜잭션 개념을 컴퓨터 과학 영역에 적용해보자. 우리 주변에서 볼 수 있는 대부분의 트랜잭션(은행, 자동차 렌탈, 식료품 구매)을 컴퓨터에 반영해 보면 시스템 상태 변환 과정이라는 것을 알 수 있다.

- 시스템 상태는 변경 가능한 값을 가진 장치와 레코드들로 구성된다.
- 시스템 상태에는 레코드 값 및 허용된 값 변환에 대한 단언(assertions)이 포함된다.
    - 이러한 단언을 시스템 일관성 제약이라 부른다.
- 시스템은 기록과 장치의 값을 읽고 변환하는 작업을 제공한다.
- 상태의 일관된 변환을 구성하는 작업 모음을 그룹화해서 하나의 트랜잭션을 형성할 수 있다.
- 트랜잭션은 시스템 일관성 제약을 보존한다.
    - 즉, 일관성있는 상태를 새로운 일관성 있는 상태로 변환하는 방식을 통해 규칙을 준수한다.
- 트랜잭션은 원자적이고 지속성이 있어야 한다.
    - 모든 작업이 수행된 이후에는 트랜잭션이 커밋되거나, 트랜잭션의 효과가 유지되지 않고 취소되었거나 둘 중의 하나여야 한다.

무시되어야 하는 작업이나 취소할 수 없는 작업 등을 설명하기 위해 몇 가지 개념을 더 추가하자.

>
- Unprotected: the action need not be undone or redone if the transaction must be aborted or the entity value needs to be reconstructed.
- Protected: the action can and must be undone or redone if the transaction must be aborted or if the entity value needs to be reconstructed.
- Real: once done, the action cannot be undone.

- Unprotected: 트랜잭션을 중단해야 하거나 엔티티 값을 재구성해야 하는 경우에도 작업을 실행 취소하거나 다시 실행할 필요가 없음.
- Protected: 트랜잭션을 중단해야 하거나 엔티티 값을 재구성해야 하는 경우라면 작업을 실행 취소하거나 다시 실행할 수 있음.
- Real: 일단 완료되면 작업을 취소할 수 없음.

이에 대해 다음과 같이 예를 들 수 있다.
- Unprotected: 임시 파일에 대한 작업이나 중간 메시지 전송.
- Protected: 일반적인 데이터베이스 및 메시지 작업.
- Real: 실제 존재하는 장치들(현금 지급기, 비행기 날개)에 대한 거래 약속 및 운영.

각각의 트랜잭션은 "커밋" 또는 "취소"라는 둘 중 하나의 결과를 내며 종료된다.

- 커밋된 트랜잭션의 모든 protected 또는 real 작업은 실패가 발생한 경우에도 계속 유지된다.
- 그러나 중단된(aborted) 트랜잭션의 protected 또는 real 작업의 영향은 다른 트랜잭션에서는 볼 수 없다.

일단 트랜잭션이 커밋되면, 다른 추가 트랜잭션을 실행해야지만 그 결과를 변경할 수 있다. 예를 들어 보자.

- 누군가가 돈을 부족하게 받았다면, 이에 대한 수정 조치는 부족한 만큼의 추가 금액을 지불하는 다른 트랜잭션을 실행하는 것이다.
- 이러한 사후 거래(post facto transactions)를 보상 거래(compensating transactions)라고 한다.


간단한 트랜잭션과 복잡한 트랜잭션.

- 간단한 트랜잭션은 한 줄로 이어지는 일련(linear sequence)의 작업들이다.
- 복잡한 트랜잭션은 내부에서 동시성 처리를 해야 할 수 있다.
    - 작업 그룹과의 의존성 때문에, 특정 한 작업의 초기화는 작업 그룹의 작업 결과에 따라 달라질 수 있다.
- 이러한 트랜잭션은 트랜잭션이 중첩(nested)된 것처럼 보이지만 중첩된 트랜잭션의 효과는 트랜잭션의 다른 부분에서만 볼 수 있다.

![image]( /post-img/summary-the-transaction-concept/115991313-c6c6e100-a602-11eb-8fb5-f39d555c5b49.png )

- 그림 1
    - T1: 간단한 일련의 작업.
    - T2: 병렬성과 트랜잭션 중첩이 있는 복잡한 트랜잭션.


### NonStop™: Making failures rare

**NonStop™: 실패를 거의 발생시키지 않기**

트랜잭션의 원자성과 지속성을 얻는 한 가지 방법은 절대로 실패하지 않는 완벽한 시스템을 구축하는 것이다.

다음과 같이 가정해 보자.

- 만약 당신이 실패한 적이 없는 완벽한 하드웨어와 할 일을 정확히 수행해온 소프트웨어를 만들어냈다고 하자.
- 이 시스템은 매우 인기있을 것이고 모든 거래는 항상 성공할 것이다.
- 그러나 이 시스템은 가끔 실패할 수도 있는데, 그 이유는 다음과 같다.
    - 시스템을 자신의 환경에 맞게 조정하는 사람이 실수(애플리케이션 프로그래밍 에러)를 저지른다.
    - 시스템을 운영하는 사람이 실수(데이터 입력이나 절차상의 에러)를 저지른다.
- 매우 신중하게 관리한다 해도 이 시스템은 몇 개월이나 몇 년마다 실패하는 일이 발생할 것이다.
    - 데이터 입력 오류나 인증 오류 등의 이유로 100번 중 한 번 이상은 트랜잭션이 실패할 것이다.

이에 대해 두 가지 결론을 내릴 수 있다.

1. 완벽한 시스템을 만들 필요는 없다. 천 년에 한 번 실패하는 정도로도 충분히 괜찮다.
2. 시스템이 완벽하다 할지라도, 데이터 입력 오류/자금 부족/운영자에 의한 취소/시간 초과 등으로 인해 일부 트랜잭션은 취소(abort)되게 되어 있다.

이 섹션에서는 "거의 완벽한" 시스템을 위한 기술(techniques)과 트랜잭션 처리와의 관계를 설명한다.

- 불완전성은 여러 가지 형태로 드러난다.
    - 하나의 시스템은 설계 오류나 기계 장치 오류 때문에 실패할 수 있다.
    - 오류는 사용자가 볼 수 있는 형태로 나타날 수도 있고, 검사기가 실패를 감지하여 사용자에게 보여줄 수도 있다.
- 하나의 시스템이 잘못된 작업을 수행한다면(오류가 발생했는데 감지하지 못했다면) 신뢰할 수 없는(unreliable) 시스템이다.
- 하나의 시스템이 주어진 시간 제한 내에 올바른 작업을 수행하지 않으면 가용하지 않은(unavailable) 시스템이다.
- 분명한 것은, 높은 가용성(availability)이 높은 신뢰성(reliability)보다 달성하기 어렵다는 것이다.
    - (위의 완벽한 시스템의 예를 떠올려 보자)

존 폰 노이만은 신뢰할 수 없는 구성 요소들(unreliable components)을 사용해 매우 신뢰할 수 있고(very reliable), 가용성 있는(available) 시스템을 구축할 수 있다는 것을 관찰한 바 있다. 폰 노이만의 아이디어는 다음과 같다.

- 수십년 동안 평균 무고장 시간(mean-times-to-failure)을 측정하기 위해 거대한 규모에서 다수결 함수(majority logic)를 중복해 사용한다.
    - 거대한 규모: 1개의 회선을 위해 20000개의 회선을 연결.
- 폰 노이만은 평균 고장 발생 횟수를 며칠 단위로 측정했다.
- 엄청나게 많이 사용되고 있는 시스템에 쓰인 뉴런과 진공관의 관점에서 생각했다.
- 또한 폰 노이만의 모델은 민감한 편이어서 하나의 실패만 발생해도 전체 체인을 망가뜨릴 수 있었다.


다행히도 컴퓨터 시스템은 매우 긴 기간의 평균 무고장 시간을 얻기 위해 (폰 노이만이 고려한 것과 같은) 20000개씩이나 되는 중복 요소가 필요하지 않다.

- 폰 노이만의 신경망과 달리 컴퓨터 시스템은 모듈화된 계층 구조로 이루어져 있고, 각각의 모듈은 자체 검사 기능이 있다.
    - 따라서 각 모듈은 올바르게 작동하거나, 스스로 오류를 감지하여 아무것도 하지 않는다.
    - 이러한 모듈을 **Fail-fast**라고 한다.
- 프로세서 및 메모리와 같은 Fail-fast 컴퓨터 모듈은 몇 개월 단위로 측정된 평균 무고장 시간을 달성해낸다.
- 비교적 적은 수의 모듈이 시스템을 구성하기 때문에(보통 100개 미만) 시스템 안정성을 향상시키기 위해서는 매우 제한된 중복성이 필요하다.

이 말의 의미를 알기 위해 간단하게 디스크의 경우를 생각해 보자.

- 일반적인 디스크는 약 1년에 한 번 고장난다. 고장은 디스크 표면의 불량한 지점이나, 회전축의 물리적 오류, 또는 디스크 경로상의 전기적 오류로 인해 발생한다.
- 디스크 하나를 고치거나 교체할 예비 디스크를 가져오는 데에는 약 1 시간이 걸린다.
- 만약 디스크가 이중화(미러링)되어 있고 독립적으로 실패한다면, 디스크 쌍이 둘 다 한꺼번에 다운되는 것은 약 3천년에 한 번이다.
- 좀 더 현실적으로는 평균 무고장 시간은 800년 정도이다.
- 따라서 8쌍의 디스크가 있는 시스템은 약 100년에 한 번 정도는 디스크 쌍 하나를 사용할 수 없다.
    - 만약 미러링이 없다면 동일한 시스템에서 1년에 약 8번 정도는 디스크를 사용할 수 없다.


1960년대 후반부터 이중화 디스크가 사용되었지만, 오랜 시간이 지나고 나서야 이 경험을 다음과 같이 일반화할 수 있었다.

- 모듈의 평균 무고장 시간은 개월 단위로 즉정된다.
- 모듈은 fail-fast 하게 만들 수 있다.
- 예비 모듈은 몇 초 또는 몇 분으로 측정된 평균 수리 시간을 제공한다.
- 이러한 모듈을 이중화하면 몇 백년의 동안 평균 무고장 시간을 측정할 수 있을 것이다.

이러한 아이디어를 하드웨어와 소프트웨어 양쪽에 체계적으로 적용하면 매우 신뢰할 수 있고(highly reliable), 높은 가용성을 가진(highly available) 시스템을 만들 수 있다.


높은 가용성은 시스템 디자인 컨셉의 많은 면을 다시 생각하게 한다.

예를 들어 시스템 유지보수 문제를 생각할 수 있다.

- 시스템이 작동하는 동안 특정 컴포넌트를 시스템에 연결할 수 있어야 한다.
    - 하드웨어 레벨에서 보면, 이를 위해서는 주위에 고전압이 없고, 해당 컴포넌트가 고전압과 전압 변화를 견딜 수 있다는 것 등등등에 대해 Underwriters Laboratory의 승인을 받아야 한다.
    - 소프트웨어 레벨에서는 "SYSGEN"이 없으며, 시스템이 작동하는 동안 프로그램이나 데이터 구조를 교체할 수 없음을 의미한다.
- 이러한 것들은 대부분의 최신 시스템 디자인의 관점과는 차이가 있다.
    - (높은 가용성 중심의 관점이 새로운 관점이라는 의미)

지속적인 서비스를 제공하는 시스템의 상용 버전이 시장에 나타나기 시작했다.
- 아마도 가장 잘 알려진 것은 Tandem systems일 것이다(이 논문은 Tandem Computers에서 작성되었음을 염두에 두자).
    - Tandem은 고가용성을 확보하기 위한 접근법을 NonStop(Tandem 트레이드 마크)이라 부른다.
    - 이 시스템은 일반적으로 1 ~ 10년 사이의 무고장 시간을 갖고 있다.
- 하드웨어 레벨에서 모듈과 경로는 이중화되어 있으며, 모든 컴포넌트는 안정적이고(reliable), fail-fast하게 작동하도록 설계되었다.
- 소프트웨어 레벨에서 시스템은 메시지 기반 운영 체제로 구성된다. 그리고 각 프로세스에는 기본 프로세스 또는 지원 하드웨어가 실패할 경우 기본 프로세스를 계속 작동하는 백업 프로세스를 준비할 수 있다.


고가용성 시스템을 구축하는 것은 쉽지 않은 일이다.

- 이런 시스템에서 툴이 제공되지 않을 때 내결함성(fault-tolerant) 애플리케이션을 프로그래밍하는 것은 자명하지 않은(non-trivial) 일이다.
- 프라이머리 프로세스가 실패할 경우 백업 프로세스에 의한 테이크 오버가 매우 까다롭기 때문이다.
- 백업 프로세스는 실패를 다른 프로세스로 전파하지 않고 중단된 곳에서 작업을 계속 해야한다.


내결함성(fault-tolerant) 애플리케이션을 만들기 위한 한 가지 전략은 다음과 같다.

- 각 작업 이전에 프라이머리 프로세스의 상태를 백업 프로세스에 "체크포인트"하는 것이다.
- 프라이머리 프로세스가 실패하면 백업 프로세스는 프라이머리가 남겨둔 곳부터 대화를 진행하도록 한다.
- 이러한 이벤트에서 요청자(requestor)와 서버 프로세스 사이를 다시 동기화하는 것은 매우 예민한 일이다.


내결함성 애플리케이션을 만들기 위한 또다른 전략은 다음과 같다.

- 계산의 모든 프로세스를 트랜잭션으로 함께 수집하고, 실패가 발생할 때 모든 프로세스를 초기 트랜잭션 상태로 재설정하는 것이다.
- 실패가 발생하면 트랜잭션이 (저장 지점 또는 시작 지점으로) 실행 취소되고, 새 프로세스에 의해 해당 시점부터 작동한다.
- 트랜잭션 관리에서 제공하는 backout 및 재시작 기능은 애플리케이션 프로그래머에게 실패 또는 프로세스 중복 쌍에 대한 걱정을 덜어준다.


트랜잭션 개념을 구현하는 사람은 원시 프로세스 쌍 메커니즘(primitive process-pair mechanism)을 사용해야 하며, NonStop의 섬세한 능력을 다룰 수 있어야 한다.

- 그러나 그 구현 이후부터는 모든 프로그래머가 트랜잭션 메커니즘에 의존할 수 있으므로 내결함성 소프트웨어를 쉽게 작성할 수 있다.
- 이러한 시스템의 프로그램들은 `BEGIN-TRANSACTION`, `COMMIT-TRANSACTION` 및 `ABORT-TRANSACTION` 동사를 포함한다는 점을 빼고는 기존 시스템의 프로그램과 별반 다르지 않다.


트랜잭션 개념을 사용하면 다음과 같은 장점이 있다.

- 입력 데이터나 시스템 상태가 좋아 보이지 않을 때 애플리케이션 프로그래머가 트랜잭션을 중단하는 것이 가능하다. 
    - 이 기능은 트랜잭션을 취소하는 메커니즘이 이미 들어가 있으므로 추가 비용이 들어가지 않는다.
- 또한, 트랜잭션이 logging으로 구현되면 트랜잭션 관리자를 사용하여 이전 상태와 로그를 통해 시스템 상태를 재구축할 수 있다.
    - 이 기능 덕분에 여러 건의 실패가 발생하는 경우에도 트랜잭션의 지속성을 보장할 수 있다.

요약하자면 NonStop™ 기술은 컴퓨터 시스템의 고장률을 수십년 또는 수세기 단위로 측정되도록 할 수 있다.
- 실제의 시스템은 운영자 오류(약 1년에 1번)나 애플리케이션 프로그램 오류(약 1년에 여러 차례)로 인해 몇 개월 또는 몇 년 단위로 오류가 발생할 수 있다.
- 이는 이제 제조업체에서 제공하는 소프트웨어나 하드웨어의 문제가 아닌 시스템 안정성(reliability)의 주요 한계이다.


이 섹션에서는 내결함성 애플리케이션의 구현을 용이하게 하기 위한 트랜잭션 개념의 필요성을 보여주었다.

트랜잭션 개념을 구현하는 데에는 두 가지 상이한 접근 방법이 있다. 다음 섹션에서는 이 두 가지 접근 방법을 설명한다.
- 시간 도메인 주소 지정 방법.
- 로깅 및 잠금 방법.


두 가지 기술에 대해 미리 언급하자면, 다음과 같다.
- 로깅은 모든 객체의 현재 상태를 클러스터링하고, 이전 버전을 log라는 히스토리 파일로 기록해 둔다.
- 시간 도메인 주소 지정은 각 객체의 전체 기록(모든 버전)을 객체와 함께 클러스터링 한다.

두 방법은 각각의 장점을 갖고 있다.

### UPDATE IN PLACE: A poison apple?




### TIME-DOMAIN ADDRESSING: One solution
### LOGGIN AND LOCKING: Another solution
### LIMITATIONS OF KNOWN TECHNIQUES
### NESTED TRANSACTIONS
### LONG-LIVED TRANSACTIONS
### INTEGRATION WITH PROGRAMMING LANGUAGES
### SUMMARY
### ACKNOWLEDGEMENTS
### REFERENCES

## 참고문헌

- The Transaction Concept: Virtues and Limitations by Jim Gray 1981
    - [PDF]( http://jimgray.azurewebsites.net/papers/thetransactionconcept.pdf )


