---
layout  : wiki
title   : 디미터 법칙 (The Law of Demeter)
summary : 객체는 그것이 내부적으로 보유하고 있거나 메시지를 통해 확보한 정보만 가지고 의사 결정을 내려야 한다
date    : 2020-03-22 12:13:49 +0900
updated : 2020-03-22 23:50:12 +0900
tag     : law oop
toc     : true
public  : true
parent  : [[proverb]]
latex   : false
---
* TOC
{:toc}

## 어원

- 실용주의 프로그래머(역자 주석)

> 디미터(Demeter)는 그리스 신화의 농업, 결혼, 사회 질서의 여신이다.
디미터라는 프로젝트에서 이 법칙을 발견했다고 해서 그렇게 이름 붙였다.
그 프로젝트는 소프트웨어를 '성장'시키는 방법을 사용한다(디미터가 농업의 여신이라는 점을 기억하라).[^andrew-227]

- 오브젝트

> 디미터 법칙은 "Object-Oriented Programming: An Objective Sense of Style"에서 처음으로 소개된 개념으로 이 글의 저자들은 디미터라는 이름의 프로젝트를 진행하던 도중 객체들의 협력 경로를 제한하면 결합도를 효과적으로 낮출 수 있다는 사실을 발견했다.[^cho-184]

## 의미

### From: Clean Code

> 디미터 법칙은 잘 알려진 휴리스틱으로, 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙이다.
앞 절에서 봤듯이, 객체는 자료를 숨기고 함수를 공개한다. 즉, 객체는 조회 함수로 내부 구조를 공개하면 안 된다는 의미다.
그러면 내부 구조를 (숨기지 않고)노출하는 셈이니까.  
좀 더 정확히 표현하자면, 디미터 법칙은 "클래스 C의 메서드 f는 다음과 같은 객체의 메서드만 호출해야 한다"고 주장한다.
- 클래스 C
- f가 생성한 객체
- f 인수로 넘어온 객체
- C 인스턴스 변수에 저장된 객체

> 하지만 위 객체에서 허용된 메서드가 반환하는 객체의 메서드는 호출하면 안 된다.
다시 말해, 낯선 사람은 경계하고 친구랑만 놀라는 의미다.[^bob-123]

- 짧은 설명

> 일반적으로 한 모듈은 주변 모듈을 모를수록 좋다.
좀 더 구체적으로, A가 B를 사용하고 B가 C를 사용한다 하더라도 A가 C를 알아야 할 필요는 없다는 뜻이다.[^bob-395]


### From: 테스트 주도 개발로 배우는 객체 지향 설계와 실천

> 서로 메시지를 전달하는 객체가 있다면 객체는 서로 무슨 이야기를 할까?
경험상 객체를 호출할 땐 이웃 객체가 하는 역할 측면에서 해당 객체가 무엇을 원하는지 기술하고,
호출된 객체가 그러한 바를 어떻게 실현할지 결정하게 해야 한다.
이것은 흔히 '묻지 말고 말하라' 스타일이나 좀 더 형식적으로 말하면 디미터의 법칙(Law of Demeter)으로 알려져 있다.
객체는 그것이 내부적으로 보유하고 있거나 메시지를 통해 확보한 정보만 가지고 의사 결정을 내려야 한다.
객체는 다른 객체를 탐색해 뭔가를 일어나게 해서는 안 된다.[^steve-19]

**객체는 그것이 내부적으로 보유하고 있거나 메시지를 통해 확보한 정보만 가지고 의사 결정을 내려야 한다.**

### From: 실용주의 프로그래머

> 디미터 법칙은 객체의 모든 메서드는 다음에 해당하는 메서드만을 호출해야 한다고 말한다.
- 자신
- 메서드로 넘어온 인자
- 자신이 생성한 객체
- 직접 포함하고 있는 객체

> 디미터 법칙을 따르면 함수를 호출하는 클래스의 응답집합 크기를 줄일 수 있기 때문에 좀 더 에러가 적은 클래스들을 만들 수 있다.[^andrew-231]

즉, 객체의 협력 경로를 제한하라는 의미이다.

### From: 오브젝트

- 협력 경로를 제한하라.

> 이처럼 협력하는 객체의 내부 구조에 대한 결합으로 인해 발생하는 설계 문제를 해결하기 위해 제안된 원칙이 바로 디미터 법칙(Law of Demeter)이다.
디미터 법칙을 간단하게 요약하면 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라는 것이다.[^cho-183]

- 객체의 내부 구조를 묻지 말고, 무언가를 시켜라.

> 이처럼 협력하는 객체의 내부 구조에 대한 결합으로 인해 발생하는 설계 문제를 해결하기 위해 제안된 원칙이 바로 디미터 법칙(Law of Demeter)이다.
> 디미터 법칙은 객체가 자기 자신을 책임지는 자율적인 존재여야 한다는 사실을 강조한다.
정보를 처리하는 데 필요한 책임을 정보를 알고 있는 객체에게 할당하기 때문에 응집도가 높은 객체가 만들어진다.
<br/><br/>
하지만 무비판적으로 디미터 법칙을 수용하면 퍼블릭 인터페이스 관점에서 객체의 응집도가 낮아질 수도 있다.
자세한 내용은 이번 장에 포함된 "원칙의 함정" 절을 읽어보기 바란다.
<br/><br/>
디미터 법칙은 객체의 내부 구조를 묻는 메시지가 아니라 수신자에게 무언가를 시키는 메시지가 더 좋은 메시지라고 속삭인다.
[^cho-186]

## 법칙의 준수와 위반
### 디미터 법칙을 잘 지킨 코드

디미터 법칙을 따르는 형태의 코드는 다음과 같이 매우 단순하다.

```java
object.method(parameter);
```

### 법칙을 지킬 필요가 없는 경우

한편, 객체가 아니라 자료구조라면 디미터 법칙을 거론할 필요가 없다.

>
```java
Options opts = ctxt.getOptions();
File scratchDir = opts.getScratchDir();
final String outputDir = scratchDir.getAbsolutePath();
```
(중략)  
위 예제가 디미터 법칙을 위반하는지 여부는 `ctxt`, `Options`, `ScratchDir`이 객체인지 아니면 자료 구조인지에 달렸다.
객체라면 내부 구조를 숨겨야 하므로 확실히 디미터 법칙을 위반한다.
반면, 자료 구조라면 당연히 내부 구조를 노출하므로 디미터 법칙이 적용되지 않는다.[^bob-124]

디미터 법칙은 경우에 따라 판별이 매우 애매하므로 이분법적으로 생각하지 않도록 한다.

### 디미터 법칙을 위반한 코드 - 기차 충돌

> 이 법칙을 따르지 않으면 메시지 체인(Message Chains)이란 악취가 나게 된다.[^andrew-227]

디미터 법칙을 위반한 전형적인 코드의 형태는 다음과 같다.

```java
object.getChild().getContent().getItem().getTitle();
```

`getter`가 줄줄이 이어진 모습이 기차와 닮아서 **열차 전복, 기차 충돌(train wreck)** 이라는 단어로 표현하기도 한다.

> 이 스타일을 따르지 않으면 '열차 전복' 코드라고도 알려진 코드가 만들어진다.
바로 접근자(getter) 메서드가 기차 객차처럼 연이어 이어진 경우다.
다음은 인터넷에서 발견한 '열차 전복' 코드의 한 예다.
```java
((EditSaveCustomizer) master.getModelisable()
  .getDockablePanel()
    .getCustomizer())
      .getSaveItem().setEnabled(Boolean.FALSE.booleanValue());
```
잠깐 생각해보니 원래 코드가 다음과 같은 코드를 의미한다는 사실을 깨달았다.
```java
master.allowSavingOfCustomisations();
```
이렇게 하면 모든 구현 세부 사항이 메서드 호출 한 번으로 줄어든다.[^steve-19]

## 주의: 디미터 법칙은 하나의 . 을 강제하는 규칙이 아니다

>
앞에서 설명한 것처럼 디미터 법칙은 "오직 하나의 도트만을 사용하라"는 말로 요약되기도 한다. 따라서 대부분의 사람들은 자바 8의 `IntStream`을 사용한 아래의 코드가 기차 충돌을 초래하기 때문에 디미터 법칙을 위반한다고 생각할 것이다.
```java
IntStream.of(1, 15, 20, 3, 9)
    .filter(x -> x > 10)
    .distinct()
    .count();
```
> 하지만 이것은 디미터 법칙을 제대0로 이해하지 못한 것이다.
위 코드에서 `of`, `filter`, `distinct` 메서드는 모두 `IntStream`이라는 동일한 클래스의 인스턴스를 반환한다. 즉, 이들은 `IntStream`의 인스턴스를 또다른 `IntStream`의 인스턴스로 변환한다.

> 따라서 이 코드는 디미터 법칙을 위반하지 않는다.
디미터 법칙은 결합도와 관련된 것이며, 이 결합도가 문제가 되는 것은 객체의 내부 구조가 외부로 노출되는 경우로 한정된다.
`IntStream`의 내부 구조가 외부로 노출됐는가? 그렇지 않다. 단지 `IntStream`을 다른 `IntStream`으로 변환할 뿐, 객체를 둘러싸고 있는 캡슐은 그대로 유지된다.

> 하나 이상의 도트(.)를 사용하는 모든 케이스가 디미터 법칙 위반인 것은 아니다. 기차 충돌처럼 보이는 코드라도 객체의 내부 구현에 대한 어떤 정보도 외부로 노출하지 않는다면 그것은 디미터 법칙을 준수한 것이다.[^cho-198]

## 부록: 메시지 체인의 리팩토링

마틴 파울러의 "리팩토링"을 읽어보면 메시지 체인에 대한 언급이 있다.

> 메시지 체인은 클라이언트가 한 객체에 제 2의 객체를 요청하면, 제 2의 객체가 제 3의 객체를 요청하고, 제 3의 객체가 제 4의 객체를 요청하는 식으로 연쇄적 요청이 발생하는 문제점을 뜻한다.
이러한 메시지 체인은 수많은 코드 행이 든 `getThis` 메서드나 임시변수 세트라고 봐도 된다.
이런 요청의 왕래로 인해 클라이언트는 그 왕래 체제에 구속된다.
그 사이의 관계들에 수정이 발생할 때마다 클라이언트도 수정해야 한다.

> 이럴 때는 대리 객체 은폐(Hide DElegate, 195쪽)를 실시해야 한다.
이 기법은 원칙적으로 체인을 구성하는 모든 객체에 적용할 수 있지만, 그렇게 하면 모든 중간 객체가 중개 메서드로 변해서 과잉 중개 메서드(middle man)의 구린내를 풍기는 문제가 흔히 발생한다.
그래서 차라리 결과 객체가 어느 대상에 사용되는지를 알아내는 방법이 더 낫다.
그렇게 알아낸 객체가 사용되는 코드 부분을 메서드 추출(Extract Method, 142쪽)을 통해 별도의 메서드로 빼낸 후 메서드 이동(Move Method, 178쪽)을 실시해서 체인 아래로 밀어낼 수 있는지 여부를 검사해야 한다. 만약 체인에 속한 객체 중 한 객체의 여러 클라이언트가 나머지 객체들에 왕래한다면 그 기능을 수행하는 메서드를 추가하면 된다.
[^fowler-111]

## 참고문헌

- Clean Code / 로버트 C. 마틴 저/박재호, 이해영 역 / 인사이트(insight) / 초판 3쇄 2016년 05월 25일
- 리팩토링 / 마틴 파울러 저 / 김지원 역 / 한빛미디어 / 초판 2쇄 2013년 03월 07일 / 원서 : Refactoring (Addison-Wesley Professional; 1 edition, 1999)
- 실용주의 프로그래머 / 앤드류 헌트,데이비드 토머스 공저 / 김창준,정지호 공역 / 인사이트(insight) / 초판 1쇄 2005년 08월 15일
- 오브젝트 / 조영호 저 / 위키북스 / 2쇄 2019년 07월 17일
- 테스트 주도 개발로 배우는 객체 지향 설계와 실천 / 스티브 프리먼, 냇 프라이스 공저 / 인사이트(insight) / 초판 3쇄 2016년 07월 05일 / 원제 : Growing object-oriented software, guided by tests

## 주석

[^andrew-227]: 실용주의 프로그래머. 5장. 227쪽.
[^andrew-231]: 실용주의 프로그래머. 5장. 231쪽.

[^cho-183]: 오브젝트. 6장. 183쪽.
[^cho-184]: 오브젝트. 6장. 184쪽.
[^cho-185]: 오브젝트. 6장. 185쪽.
[^cho-186]: 오브젝트. 6장. 184쪽.
[^cho-198]: 오브젝트. 6장. 198쪽.
[^steve-19]: 테스트 주도 개발로 배우는 객체 지향 설계와 실천. 2장. 19쪽.

[^bob-123]: Clean Code. 6장. 123쪽.
[^bob-124]: Clean Code. 6장. 124쪽.
[^bob-395]: Clean Code. 17장. 395쪽.

[^fowler-111]: 리팩토링. Chapter 3. 111쪽.
