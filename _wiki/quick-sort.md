---
layout  : wiki
title   : 퀵 정렬 (Quick Sort)
summary : 빠른정렬
date    : 2020-07-19 14:19:21 +0900
updated : 2020-07-19 15:31:17 +0900
tag     : sort
toc     : true
public  : true
parent  : [[algorithm]]
latex   : true
---
* TOC
{:toc}

## From: TAOCP

> 그럼 이와는 상당히 다른, 각 비교의 결과를 이용해서 다음번에 비교할 키들을 결정하는 전략을 살펴보자.
그와 같은 전략은 병렬 계산에는 부적합하지만, 직렬로 작동하는 컴퓨터에서는 상당히 이득이 된다.
>
> 여기서 말하는 방법의 기본적인 발상은 이런 것이다. 한 레코드(이를테면 $$R_1$$)를 취하고,
그것을 정렬된 파일에서 차지해야 할 최종 위치(이를테면 $$s$$)로 이동한다.
이 최종 위치를 결정하는 도중에, 위치 $$s$$의 왼쪽에 현재 레코드의 키보다 더 큰 키들이 존재하지 않도록,
그리고 그 오른쪽에는 그보다 더 작은 키들이 존재하지 않도록 다른 레코드들도 적절히 재배치한다.
결국 파일은 원래의 정렬 문제가 두 개의 보다 간단한 문제들, 즉 $$R_1 ... R_{s-1}$$과 $$R_{s+1} ... R_N$$을 각각 독립적으로 정렬하는 문제들이 되는 방식으로 분할된다.
각 부분파일들에도 마찬가지 기법을 적용한다. 그러다 보면 결국은 파일 전체가 제대로 정렬된다.
[^KNU-5-2-2]

### 분할 교환 정렬 알고리즘

TAOCP에는 다음과 같은 분할 교환 정렬도 함께 소개된다.

> 파일을 왼쪽, 오른쪽 부분파일들로 분할하는 방법은 여러 가지가 있는데, 세지윅(R. Sedgewick)에서 기인한 다음과 같은 방법이 알고리즘을 분석하기에 좀 더 깔끔하다는 점에서 최선인 것 같다.

이 방법은 다음과 같다.

- 수열 $$R$$이 주어진다. 이 수열 $$R$$을 분할하며 정렬할 것이다.
    - 분할은 왼쪽과 오른쪽 부분으로 나눈다.
- 두 개의 포인터 `i`, `j`를 둔다.
    - 초기값은 `i = 2`, `j = N`이다.
    - 왼쪽과 오른쪽으로 나누는 기준은 가장 왼쪽 원소이다.
- 만약 $$R_i$$가 분할 이후에 왼쪽 부분으로 가게 된다면, `i`를 `1` 증가한다.
    - 이 과정을 오른쪽 부분파일에 속할 레코드 $$R_i$$에 도달할 때까지 반복한다.
- `j`는 왼쪽 부분파일에 속할 레코드 $$R_j$$를 만날 때까지 계속 감소한다.
- 만약 $$i \le j$$이면 $$R_i$$를 $$R_j$$와 교환한다.
- 이 작업을 양쪽에서 $$ i \ge j $$가 될 때까지 반복한다.

다음은 이 작업을 수행한 예제이다.

![]( /post-img/quick-sort/split.jpg )

이 예제만 봐서는 이해가 잘 가지 않는다. 그래서 한 줄 한 줄 설명을 적어 보았다.

```ascii-art
        i                                                                     j
[ 503  087  512  061  908  170  897  275  653  426  154  509  612  677  765  703 ]
```

- `i = 2` 이므로 $$R_i = R_2 = 087$$. 그리고 $$R_j = 703$$.
    - `087`은 `503`보다 작다. 왼쪽 부분이다.
    - `703`은 `503`보다 크다. 오른쪽 부분이다.
    - 둘 다 교환하지 않아도 된다.

```ascii-art
             i                                       j
[ 503  087  512  061  908  170  897  275  653  426  154  509  612  677  765  703 ]
```

- `i`는 한 칸씩 오른쪽으로 가다가 `503`보다 큰 `512`에서 멈춘 상태.
- `j`는 한 칸씩 왼쪽으로 오다가 `503`보다 작은 `154`에서 멈춘 상태.
- 이제 `512`와 `154`의 위치를 바꾼다. (아래 그림의 `---`)

```ascii-art
                       i                        j
[ 503  087  154  061  908  170  897  275  653  426  512  509  612  677  765  703 ]
            ---                                     ---
```

- `i`는 한 칸씩 오른쪽으로 가다가 `503`보다 큰 `908`에서 멈춘 상태.
- `j`는 한 칸씩 왼쪽으로 오다가 `503`보다 작은 `426`에서 멈춘 상태.
- 이제 `908`과 `426`은 위치를 바꾼다.

```ascii-art
                                 i    j
[ 503  087  154  061  426  170  897  275  653  908  512  509  612  677  765  703 ]
                      ---                      ---
```

- 똑같은 방법으로 `i`는 `897`, `j`는 `275`에서 멈춘 상태.
- `897`과 `275`는 위치를 바꾼다.

```ascii-art
                                 j    i
[ 503  087  154  061  426  170  275  897  653  908  512  509  612  677  765  703 ]
                                ---  ---
```

- 그리고 두 포인터 `i`, `j`는 서로 만난다(Pointer cross).

```ascii-art
                                  j     i
[ 275  087  154  061  426  170 ] 503 [ 897  653  908  512  509  612  677  765  703 ]
  ---                            ---
```

- 이제 `275`와 `503`을 교환한다.
- `503`은 정렬이 완료된 숫자가 된다.
- `275` ~ `170`은 왼쪽으로 분할된다.
- `897` ~ `703`은 오른쪽으로 분할된다.

이제 분할된 각 수열에 대해 같은 과정을 반복하면 된다.

> 이 방법은 호어(C. A. R. Hoare)[^hoare]에서 기인한 것으로,
그의 흥미로운 논문은 지금까지 출판된 것들 중 하나의 정렬 방법에 대해 가장 상세한 설명을 담은 논문에 속한다고 할 수 있다.
호어는 그의 방법을 "빠른정렬(quicksort)"이라고 불렀는데, 그 이름은 과장이 아니다.
계산의 내부 루프들이 대부분의 컴퓨터에서 극도로 빠르기 때문이다.
한 주어진 시기에서 일어나는 모든 비교는 같은 키에 대한 것이므로,
이 키를 하나의 레지스터 안에 담아둘 수 있다.
비교들 사이에서는 색인 하나만 바꾸면 된다.
게다가 자료 이동 횟수도 상당히 적당하다.
예를 들어 표2의 경우 교환 횟수는 단 17이다.
>
> i와 j, 그리고 스택을 제어하는 데 필요한 관리 작업이 어려운 것은 아니나,
그래도 그 작업 부담 때문에 빠른정렬의 분할 절차는 N이 상당히 클 때 가장 적합하다.
[^KNU-5-2-2]



## From: 로버트 세지윅, 알고리즘

> 퀵-정렬의 내부 루프(분할 메서드에 있는)는 인덱스를 증가시켜가며 어떤 고정된 값과 배열 항목의 값을 비교한다.
이러한 단순함이 퀵0정렬을 빠르게 하는 요인 중 하나이다.
정렬 알고리즘으로서, 이보다 더 짧은 내부 루프를 고안하기는 어렵다.
예를 들어 [[merge-sort]]{병합 정렬}이나 [[shell-sort]]{셸-정렬}이 전형적으로 더 느린 이유는 내부 루프에서 데이터 이동까지 하기 때문이다.
>
> 퀵-정렬을 빠르게 하는 두 번째 요인은 적은 수의 비교 연산을 하기 때문이다.
퀵-정렬의 효율은 종국적으로 배열을 얼마나 잘 분할 하느냐에 달려 있다. 그리고 이 부분은 어떤 항목을 분할 기준 항목으로 선택하느냐에 달려 있다.
그리고 이 부분은 어떤 항목을 분할 기준 항목으로 선택하느냐에 의해 결정된다.
[^SED-2-292]


## 함께 읽기

- [[merge-sort]]
- [[shell-sort]]

## 참고문헌

- [KNU] The art of computer programming 3 정렬과 검색(개정2판) / 도널드 커누스 저 / 한빛미디어 / 초판 2쇄 2013년 02월 10일
- [SED] 알고리즘 [개정4판] / 로버트 세지윅, 케빈 웨인 저/권오인 역 / 길벗 / 초판발행 2018년 12월 26일

## 주석

[^KNU-5-2-2]: [KNU] 5.2.2장.
[^SED-2-292]: [SED] 2장. 292쪽.
[^hoare]: 퀵 정렬을 고안한 컴퓨터 과학자.

