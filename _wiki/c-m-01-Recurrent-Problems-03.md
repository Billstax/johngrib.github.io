---
layout  : wiki
title   : 구체수학 01.재귀적인 문제들.03.요세푸스 문제
summary : 01.RECURRENT PROBLEMS
date    : 2018-04-26 21:58:11 +0900
updated : 2018-04-28 16:49:43 +0900
tags    : math
toc     : true
public  : true
parent  : study-concrete-math
latex   : true
---
* TOC
{:toc}

# 개요

* 이 문서는 [[CONCRETE-MATH]]책의 1장을 공부하며 메모한 것입니다.
* 이 문서는 메모일 뿐이니 자세한 내용은 교재를 참고해야 합니다.


# 1.3 요세푸스 문제(THE JOSEPHUS PROBLEM)

1세기의 역사가 플라비우스 요세푸스(Flavius Josephus)의 이름을 딴 문제를 변형한 문제.

* 제 1차 유대-로마 전쟁 중, 41명의 유대인 반역자들을 한 동굴에 모아놓았다.
* 반역자들은 갇혀있기 싫어서 자살을 하기로 결심하였다.
* 자살하는 방식은 다음과 같다.
    * 둥글에 원을 그리고 앉는다.
    * 원을 따라 두 번째 사람을 죽인다.
    * 모두가 죽을 때까지 이를 반복한다.
* 그런데 두 사람(요세푸스와 그의 친구)은 죽고 싶지 않았다.

>
요세푸스와 친구는 원의 어느 위치에 있어야 살아남을 수 있을까?

최초에 `n`명이 원에 앉아 있을 때, 마지막에 살아남는 사람의 번호를 `J(n)`이라 하자.

그렇다면 위의 문제는 임의의 `n`에 대하여 `J(n)`의 값을 구하는 문제로도 볼 수 있다.

값을 미리 계산할 수 있다면, 살아남는 자리를 차지하여 죽지 않을 수 있다.


## 작은 사례부터 생각하자

`n = 10` 인 경우부터 생각해보자.

{% raw %}
<svg height="140" width="140">
    <circle cx="70" cy="70" r="40" stroke="black" fill="transparent"></circle>
    <circle cx="73" cy="38" r="2" stroke="red" fill="red"></circle>
    <text x="70" y="20"> 1 </text>
    <text x="100" y="30"> 2 </text>
    <text x="115" y="55"> 3 </text>
    <text x="115" y="90"> 4 </text>
    <text x="100" y="120"> 5 </text>
    <text x="70" y="130"> 6 </text>
    <text x="40" y="120"> 7 </text>
    <text x="15" y="90"> 8 </text>
    <text x="15" y="55"> 9 </text>
    <text x="30" y="30"> 10 </text>
</svg>
{% endraw %}

* `1`부터 세어나가며 죽인다고 할 때 죽이는 순서는 `2, 4, 6, 8, 10, 3, 7, 1, 9` 이다.
* 따라서, `J(10) = 5`

`n`이 작을 때 `n`과 `J(n)`과의 관계를 간단히 표로 정리해 보자.

| n | J(n) | 죽는 순서     |
|---|------|---------------|
| 1 | 1    |               |
| 2 | 1    | 2             |
| 3 | 3    | 2, 1          |
| 4 | 1    | 2, 4, 3       |
| 5 | 3    | 2, 4, 1, 5    |
| 6 | 5    | 2, 4, 6, 3, 1 |

곰곰히 살펴보면 다음과 같은 사실을 알 수 있다.

* `2, 4, 6...` 과 같이 첫 루프에서는 짝수 번호가 전부 죽는다는 것을 알 수 있다.
* 따라서 `J(n)`은 항상 홀수이다.
* `n`이 짝수이면, 첫 루프에서 짝수가 전부 죽고 인원수가 절반이 된다.
    * 즉 시작 인원 수가 `2n`인 경우, 첫 루프가 끝난 후의 인원 수는 `n`이 된다.

## n이 짝수인 경우

시작 인원 수가 `2n`인 경우가 흥미로우니 좀 더 생각해보자.

{% raw %}
<svg height="140" width="140">
    <circle cx="70" cy="70" r="40" stroke="black" fill="transparent"></circle>
    <circle cx="73" cy="38" r="2" stroke="red" fill="red"></circle>
    <text x="70" y="20"> 1 </text>
    <text x="100" y="30"> 3 </text>
    <text x="115" y="55"> 5 </text>
    <text x="115" y="90"> 7 </text>
    <text x="70" y="130"> ... </text>
    <text x="0" y="65"> 2n - 3 </text>
    <text x="10" y="35"> 2n - 1 </text>
</svg>
{% endraw %}

`1, 2, 3, 4...` 가 `1, 3, 5, 7...` 이 된 셈이므로, 각 번호에 `2를 곱하고 1을 뺀 것`과 똑같은 모양이 되었다.

그렇다면 다음과 같이 표현할 수 있을 것이다.

$$ J(2n) = 2J(n) - 1, \quad for \; n \ge 1 $$

이제 `J(10)`의 값이 5 라는 것을 알고 있기 때문에 `J(20)`의 값도 구할 수 있게 되었다.

$$
\begin{align}
J(20)
    & = 2J(10) - 1 \\
    & = 2 \times 5 - 1 \\
    & = 9 \\
\end{align}
$$


## n이 홀수인 경우

n이 홀수인 경우는 어떻게 될까?

* 사람의 수가 `2n + 1`만큼 있다고 가정하자.
* 일단 첫 루프에서는 `2, 4, 6, 8, ... 2n` 과 같이 모든 짝수 번호가 죽는다.
* 그리고 마지막 `2n + 1` 번째 사람을 건너뛰게 되므로, 두 번째 루프에서는 `1` 이 가장 먼저 죽는다.

아무래도 두 번째 루프가 시작되고 `1`이 죽고 난 다음까지를 첫 번째 루프로 생각하는 쪽이 쉬울 것 같다.

그렇다면 새로 정의한 첫 번째 루프가 끝난 직후는 다음과 같을 것이다.

{% raw %}
<svg height="140" width="140">
    <circle cx="70" cy="70" r="40" stroke="black" fill="transparent"></circle>
    <circle cx="73" cy="38" r="2" stroke="red" fill="red"></circle>
    <text x="70" y="20"> 3 </text>
    <text x="100" y="30"> 5 </text>
    <text x="115" y="55"> 7 </text>
    <text x="115" y="90"> 9 </text>
    <text x="70" y="130"> ... </text>
    <text x="0" y="65"> 2n - 1 </text>
    <text x="10" y="35"> 2n + 1 </text>
</svg>
{% endraw %}

`1, 2, 3, 4...` 가 `3, 5, 7, 9...` 가 된 셈이므로, 각 번호에 `2를 곱하고 1을 더한 것`과 같은 모양이 되었다.

그러므로, 짝수인 경우와 비슷하게 식을 표현할 수 있다.

$$ J(2n+1) = 2J(n) + 1, \quad for \; n \ge 1 $$


## 점화식

위에서 얻어낸 식을 토대로 다음과 같은 점화식을 만들 수 있다.

$$
\begin{array}{ll}
J(1)      & = 1; \\
J(2n)     & = 2J(n) - 1, \quad for \; n \ge 1 \\
J(2n + 1) & = 2J(n) + 1, \quad for \; n \ge 1 \\
\end{array}
$$

이 점화식은 루프를 돌 때마다 `n`이 절반으로 줄어들게 되므로 효율적이다.

그러나 생사가 달린 문제이므로 (더 빠르게 계산할 수 있는)닫힌 형태의 해를 구하고 싶다.


## 해를 구해보자

점화식을 사용해 다음과 같은 표를 쉽게 찾아낼 수 있다.

| n  | J(n)  |           |
|----|-------|-----------|
| 1  | **1** |           |
| 2  | **1** | 2J(1) - 1 |
| 3  | 3     | 2J(2) + 1 |
| 4  | **1** | 2J(2) - 1 |
| 5  | 3     | 2J(2) + 1 |
| 6  | 5     | 2J(3) - 1 |
| 7  | 7     | 2J(3) + 1 |
| 8  | **1** | 2J(4) - 1 |
| 9  | 3     | 2J(4) + 1 |
| 10 | 5     | 2J(5) - 1 |
| 11 | 7     | 2J(5) + 1 |
| 12 | 9     | 2J(6) - 1 |
| 13 | 11    | 2J(6) + 1 |
| 14 | 13    | 2J(7) - 1 |
| 15 | 15    | 2J(7) + 1 |
| 16 | **1** | 2J(8) - 1 |

* `J(n)`은 홀수이며, `1`로 시작하고, `2`씩 증가한다.
* `n`이 `2`의 거듭제곱일 때마다 `J(n)`의 값은 `1`이 된다.

따라서 `n`을 $$ n = 2^m + l $$로 생각할 수 있다. (단, $$m \ge 0$$ 이고, $$ 0 \le l \lt 2^m $$)

그렇게 되면 각 `n`은 다음과 같이 대응된다.


| n | $$2^m + l$$ | n | $$2^m + l$$ | n | $$2^m + l$$ | n  | $$2^m + l$$ |
|---|-------------|---|-------------|---|-------------|----|-------------|
| 1 | $$2^0 + 1$$ | 2 | $$2^1 + 0$$ | 4 | $$2^2 + 0$$ | 8  | $$2^3 + 0$$ |
|   |             | 3 | $$2^1 + 1$$ | 5 | $$2^2 + 1$$ | 9  | $$2^3 + 1$$ |
|   |             |   |             | 6 | $$2^2 + 2$$ | 10 | $$2^3 + 2$$ |
|   |             |   |             | 7 | $$2^2 + 3$$ | 11 | $$2^3 + 3$$ |
|   |             |   |             |   |             | 12 | $$2^3 + 4$$ |
|   |             |   |             |   |             | 13 | $$2^3 + 5$$ |
|   |             |   |             |   |             | 14 | $$2^3 + 6$$ |
|   |             |   |             |   |             | 15 | $$2^3 + 7$$ |

점화식이 다음과 같으므로,

$$
\begin{array}{ll}
J(1)      & = 1; \\
J(2n)     & = 2J(n) - 1, \quad for \; n \ge 1 \\
J(2n + 1) & = 2J(n) + 1, \quad for \; n \ge 1 \\
\end{array}
$$

다음과 같은 식을 세울 수 있다.

$$ J(2^m + l) = 2l + 1, \quad for \; m \ge 0 \; and \; 0 \le l \lt 2^ m $$

이제 수학적 귀납법으로 이 식을 증명하자.

### 짝수인 경우

* $$2^m + l = 2k$$ 인 경우를 생각해 보자.
* $$l$$은 홀수일 수 없으므로, 짝수이다.

$$ J(2k) = 2J(k) - 1 $$ 이고, $$2^m + l = 2k$$ 이므로, 다음과 같이 식을 꾸밀 수 있다.

$$
\begin{align}
J(2^m + l)
    & = 2J(\frac{2^m + l}{2}) - 1 \\
    & = 2J(2^{m - 1} + \frac{l}{2}) - 1 \\
\end{align}
$$

그런데 $$ J(2^m + l) = 2l + 1 $$ 이므로,

$$ J(2^{m - 1} + \frac{l}{2}) = \frac{2l}{2} + 1$$ 이다.

따라서 다음과 같은 결과가 나온다.

$$
\begin{align}
J(2^m + l)
    & = 2J(2^{m - 1} + \frac{l}{2}) - 1 \\
    & = 2(\frac{2l}{2} + 1) - 1 \\
    & = 2l + 1 \\
\end{align}
$$

이는 위에서 추측한 식과 맞아 떨어진다.

### 홀수인 경우

홀수인 경우는 책에 안 나오지만 해보도록 하자.

* $$ 2^m + l = 2k + 1 $$ 인 경우를 생각해 보자.
* $$ l $$은 짝수일 수 없으므로, 홀수이다.
* $$ J(2k + 1) = 2J(k) + 1$$ 이고,  
* $$2^m + l = 2k + 1$$ 이고,
* $$ k = \frac{2^m + l - 1}{2}$$ 이므로,

다음과 같이 식을 꾸밀 수 있다.

$$
\begin{align}
J(2k + 1) & = 2J(k) + 1 \\
J(2^m + l)
    & = 2J(\frac{2^m + l - 1}{2}) + 1 \\
    & = 2J(2^{m-1} + \frac{l - 1}{2}) + 1 \\
\end{align}
$$

그런데 $$ J(2^m + l) = 2l + 1 $$ 이므로,

$$ J(2^{m - 1} + \frac{l - 1}{2}) = (l - 1) + 1 = l$$ 이다.

따라서 다음과 같은 결과가 나온다.

$$
\begin{align}
J(2^m + l)
    & = 2J(2^{m-1} + \frac{l - 1}{2}) + 1 \\
    & = 2l + 1 \\
\end{align}
$$

이 또한 위에서 추측한 식과 맞아 떨어진다.

## 2진법으로 풀면 쉽게 풀린다?

`n`을 다음과 같이 표현할 수 있을 것이다.

$$ n = b_m 2^m + b_{m-1} 2^{m - 1} + ... + b_1 2^1 + b_0 2^0 $$

위의 `n`을 다음과 같이 이진수 전개하는 것도 생각해 볼 수 있는 일이다.

$$
n = (b_m b_{m-1} ... b_{1} b_{0})_2
$$

* 단, 각 $$b_i$$ 는 `0` 또는 `1` 이다.
* 단, 제일 앞 비트인 $$b_m$$ 은 `1` 이다.

한편, $$n = 2^m + l$$ 이므로 다음과 같이 표현할 수 있다.

* $$n = (1 b_{m - 1} b_{m - 2} ... b_1 b_0)_2 $$ &nbsp;
* $$l = (0 b_{m - 1} b_{m - 2} ... b_1 b_0)_2 $$ &nbsp;
    * $$l = n \; mod \; 2^m$$ 이기 때문에, $$n$$의 제일 앞자리를 0 으로 바꾼 값이 $$l$$이다.
* $$2l = (b_{m - 1} b_{m - 2} ... b_1 b_0 0)_2 $$ &nbsp;
    * `2l`은 `l << 1` 과 같으므로, 제일 오른쪽에 0 을 추가해주면 된다.
* $$2l + 1 = (b_{m - 1} b_{m - 2} ... b_1 b_0 1)_2 $$ &nbsp;

$$J(n) = 2l + 1$$ 이므로 다음과 같이 정리할 수 있다.

$$
\begin{align}
J(n)
    & = 2l + 1 \\
    & = (b_{m - 1} b_{m - 2} ... b_1 b_0 1)_2 \\
    & = (b_{m - 1} b_{m - 2} ... b_1 b_0 b_m)_2 \\
\end{align}
$$

그런데 $$n = (1 b_{m - 1} b_{m - 2} ... b_1 b_0)_2 $$ 이므로, 다음이 증명된다.

$$
\begin{align}
J(n)
    & = (b_{m - 1} b_{m - 2} ... b_1 b_0 b_m)_2 \\
J((b_m b_{m - 1} b_{m - 2} ... b_1 b_0)_2)
    & = (b_{m - 1} b_{m - 2} ... b_1 b_0 b_m)_2 \\
\end{align}
$$

즉, n을 왼쪽으로 1회 비트 순환시키면 `J(n)`이 나온다.

단, 가장 왼쪽 비트가 `0` 일 경우엔 가장 왼쪽 비트를 삭제해 주어서, 제일 앞 비트를 `1`로 유지해 주어야 한다.

아름답다.

놀라움을 음미하기 위해 몇 가지 경우를 생각해 보자.

* `n = 13` 인 경우
    * `13 = 8 + 4 + 1` 이므로, `1101(2)` 이다.
    * 이를 회전시키면 `1011(2) = 11` 이 나온다.
* `n = 100` 인 경우
    * `100 = 64 + 32 + 4` 이므로, `1100100(2)` 이다.
    * 이를 회전시키면 `1001001(2) = 64 + 8 + 1 = 73` 이다.
    * $$100 = 2^6 + 36 $$ 이므로, $$l = 36$$ 이고, $$2l + 1$$에 의해 `73`이 맞다.

## 재귀시키는 경우

즉 함수 `J(n)`은 다음과 같은 작업을 한다.

* `n`의 제일 왼쪽에 있는 `1`을 가장 오른쪽으로 옮긴다.
* `1`을 옮긴 결과, 제일 왼쪽에 `0` 또는 `00...`이 있다면 삭제한다.
    * 결과는 항상 `1`로 시작해야 하기 때문이다.

문제는 어느 정도 풀었지만, 함수 `J(n)`을 재귀시키는 경우를 생각해보자.

* 함수 `J(J(J(...J(n)...)))` 과 같이 재귀시키면, 충분히 많이 돌릴 경우 `0`은 전부 사라지고 `1`만 남게 될 것이다.

예를 들어 `101101101101011(2)`를 충분히 회전시키면 `0`이 전부 삭제되어 `1111111111(2) = 1023`이 남게 될 것이다.



# Links

* [[CONCRETE-MATH]]


