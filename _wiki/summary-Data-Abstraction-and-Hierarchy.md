---
layout  : wiki
title   : (요약) Data Abstraction and Hierarchy by Barbara Liskov 1988
summary : 
date    : 2019-10-06 12:00:14 +0900
updated : 2019-10-06 15:22:29 +0900
tag     : summary
toc     : true
public  : true
parent  : index
latex   : false
---
* TOC
{:toc}

# ABSTRACT

**개요**

* 데이터 추상화는 프로그램을보다 쉽게 수정하고 유지 관리 할 수 있도록 구성하는 유용한 방법이다.
* 상속은 데이터 추상화의 한 구현을 다른 계층과 관계지을 수 있다.
* 이 논문은 프로그램 개발 측면에서 계층 구조의 유용성을 조사한다. 그리고 데이터 추상화가 더 중요한 아이디어이긴 하지만, 계층 구조는 일부 상황에서 더욱 유용하다는 결론을 내린다.

# 1. Introduction

* 설계의 중요한 목표: 변화하는 요구 사항을 지원하기 위한 유지보수를 단순화할 수 있는 프로그램 구조를 알아내는 것.
* 데이터 추상화는 이 목표를 달성하는 좋은 방법.
* 객체 지향 프로그래밍은 주로 데이터 추상화 기술이며, 상당부분이 이 관점에서 파생된다.
    * 상속(inheritance) 개념이 여기에서 비롯되었다.
    * 이 논문은 데이터 추상화와 객체 지향 프로그래밍의 관계에 대해 설명한다.

논문 개요

* 2장
    * 데이터 추상화와 프로그램 개발 프로세스 역할을 정의한다.
* 3장
    * 상속에 대해 논의한다.
    * 구현 계층(implementation hierarchy)과 타입 계층(type hierarchy)에 사용되는 두 가지 방법.
* 4장
    * 프로그램 설계 및 개발에서의 타입 계층의 사용.
* 5장
    * 타입 계층을 구현할 때 발생하는 몇 가지 문제들.
* 6장
    * 결론

# 2. Data Abstraction

프로그래밍 추상화의 목적은 동작(behavior)과 구현(implementation)을 분리하는 것이다.

* 최초의 프로그래밍 추상화 메커니즘은 절차(procedure)였다.
* 절차는 유용한 추상화 메커니즘이었지만, 70년대 초의 몇몇 연구자들은 절차로는 충분하지 않다는 것을 깨닫게 됐다.
    * 모듈 간의 "연결(connections)" 주위로 프로그램을 구성하는 새로운 방법을 제안.
    * 데이터 추상화(data abstraction), 추상 데이터 유형(abstract data type) 개념은 여기에서 비롯된 것이다.

데이터 추상화는 데이터 측면에서의 이점이 있다.

* 메인 아이디어: 추상화와 구현을 분리.
    * 같은 추상화의 구현을 자유롭게 대체한다.
* 데이터 객체의 구현은 그 객체가 컴퓨터 메모리에서 어떻게 표현되는지에 대한 것이다.
    * 이런 정보를 표현(representation)이라 한다.

사용자에게 영향을 주지 않으면서 표현을 변경할 수 있는 방법이 필요.

* 표현을 캡슐화.
* 표현을 직접 조작할 수 없게 한다.
* 표현을 조작하는 대리 프로그램을 사용.

데이터 추상화는 연산 집합(a set of operations)으로만 직접 조작이 가능한 객체의 집합이다.

데이터나 프로시저 추상화는 스펙(specification)으로 정의하고, 프로그래밍 언어로 구현된다.

* 스펙(specification)은 추상화가 무엇을 하는지 설명하지만 구현에 대해서는 생략한다.
    * 이러한 생략 덕분에 많은 구현이 가능해진다.
    * 구현이 사양에 정의된 행동을 제공한다면 올바른 구현이라 할 수 있다.
    * 올바른 구현들끼리는 서로 동일할 필요가 없다.
* 추상화가 작동하려면 구현을 캡슐화해야 한다.
    * 구현이 캡슐화되면 다른 모듈은 구현의 디테일에 의존하지 않게 된다.
    * Parnas가 주장한 정보 은닉(information hiding)과 관련이 있다.


## 2.1. Locality

스펙(specification)과 캡슐화(encapsulation)에 의해 지원되는 추상화는 프로그램 내에서의 지역성(locality)을 제공한다.

* 지역성은 프로그램을 한 번에 한 모듈씩 구현하거나, 이해하거나, 수정할 수 있도록 돕는다.

1. 스펙만 보고 구현할 수 있게 된다.
2. 모듈을 사용하는 사람은 스펙을 보고 필요한 것을 파악할 수 있다.
3. 프로그램의 작업 범위를 이해할 때 일부만 검토해 보아도 된다.
    * 스펙이 구현보다 훨씬 작기 때문에 노력을 많이 절약할 수 있다.
4. 프로그램 변경은 모듈별로 수행된다.

지역성(locality)은 빠른 프로토타이핑을 위한 기반과 프로그램의 진화를 지원한다.

* 서둘러서 만들면 성능이 뒤떨어지는 경향이 있지만, 나중에 더 나은 구현으로 대체할 수 있다.
* 잠재적인 변경을 캡슐화하기 위해 추상화를 사용할 수 있다.
    * 다양한 기계에서 프로그램을 돌리기 위해, 기계들 사이의 차이를 숨기는 추상화를 만들어 사용할 수 있다.

지역성(locality)은 데이터 추상화에 특히 중요하다.

* 데이터 구조는 복잡한 경우가 많으므로, 스펙에서 제공하는 단순한 추상 뷰를 사용하면 프로그램을 더 간단하게 만들 수 있다.
* 프로그램이 발전하면서 발생하는 변경을 데이터 추상화 안에 캡슐화하여, 최소화할 수 있다.


## 2.2. Linguistic Support for Data Abstraction

* 데이터 추상화는 여러 언어에서 지원된다.
* 최초의 언어는 Simula 67.
* CLU, Smalltalk의 경우를 설명한다.

CLU는 추상 타입(abstract type)을 구현하기 위해 cluster라는 메커니즘을 제공한다.

* 데이터 타입과 해당 타입의 연산 목록을 식별.
* 타입 객체가 표현되는 방법을 정의.
* cluster 내부에서만 사용 가능한 프로시저도 있을 수 있다.

Smalltalk에서는 데이터 추상화를 위해 클래스를 구현한다.

* 클래스는 계층 구조로 배열될 수 있다.
* 클래스는 데이터 추상화를 구현한다.
* 클래스에는 메소드가 있다.
    * 단, Smalltalk에서는 외부에서 메소드를 사용하는 것을 막지 않기 때문에 내부 메소드가 없다.

이후 CLU와 Smalltalk의 간단한 비교.


# 3. Inheritance and Hierarchy

이 섹션에서는 상속 및 계층 구조를 지원하는 방법을 다룬다.

* 상속을 사용하여 프로그램을 구성하는 것은 무엇을 의미하는가?
* 상속의 두 가지 용도
    * 구현 계층
    * 타입 계층

## 3.1. Inheritance

상속이 있는 언어에서 데이터 추상화는 서로 관계 있는 여러 부분으로 구현될 수 있다.

* Smalltalk에서 클래스는 다른 클래스 메커니즘의 서브 클래스로 선언될 수 있다.
* 서브클래스는 규칙을 적용한 인스턴스 변수와 메소드를 포함하는 클래스를 직접 구현하는 것과 같다.

상속 메커니즘의 문제점: 데이터 추상화를 손상시킬 수 있다.

캡슐화를 위반하는 세 가지 경우.

* 서브 클래스가 수퍼 클래스의 인스턴트 변수에 엑세스.
* 서브 클래스가 수퍼 클래스의 private 오퍼레이션을 호출.
* 서브 클래스가 수퍼 클래스의 수퍼 클래스를 직접 참조.

캡슐화 위반과 관련하여

* 캡슐화를 위반하지 않으면 스펙만으로 수퍼클래스의 연산(operations)을 추측할 수 있다.
* 캡슐화를 위반하면 지역화의 장점을 잃게 된다.
* 캡슐화를 위반할 때의 편리한 점도 있긴 하지만 바람직하지는 않다.


## 3.2. Implementation Hierarchy

TODO: 여기 읽을 차례

## 3.3. Type Hierarchy
# 4. Benefits of Type Hierarchy
## 4.1. Incremental Design
## 4.2. Related Types
## 4.3. Organizing a Type Library
# 5. Type Hierarchy and Inheritance
## 5.1. Polymorphism
## 5.2. Multiple Implementations
# 6. Conclusions

# Links

* [Data Abstraction and Hierarchy][pdf]


[pdf]: https://pdfs.semanticscholar.org/36be/babeb72287ad9490e1ebab84e7225ad6a9e5.pdf
